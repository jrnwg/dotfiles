#!/usr/bin/env bash

set -e

DOTFILES_GIT_DIR="${DOTFILES_GIT_DIR:-$HOME/.dotfiles.git}"
DOTFILES_WORK_TREE="${DOTFILES_WORK_TREE:-$HOME}"
DOTFILES_BACKUP_DIR="${DOTFILES_BACKUP_DIR:-$HOME/.dotfiles.backup}"

function _git() {
    git --git-dir="$DOTFILES_GIT_DIR" --work-tree="$DOTFILES_WORK_TREE" "$@"
}

function bootstrap() {
    local repo_url="$1"
    local switch_to_ssh=false

    shift
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --switch-to-ssh)
                switch_to_ssh=true
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
        shift
    done

    if [ -z "$repo_url" ]; then
        echo "Usage: dot bootstrap <git-repo-url> [--switch-to-ssh]"
        exit 1
    fi

    if [ -d "$DOTFILES_GIT_DIR" ]; then
        echo "Dotfiles already exists at $DOTFILES_GIT_DIR"
        exit 1
    fi
  
    git clone --bare "$repo_url" "$DOTFILES_GIT_DIR"
    command_with_conflict_resolution checkout

    set_default_config

    if $switch_to_ssh; then
        _git remote set-url origin "$(get_ssh_url)"
    fi
}

function resolve_conflicts() {
    local timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
    local backup_dir="$DOTFILES_BACKUP_DIR/$timestamp"

    echo "Backing up conflicting files to $backup_dir..."
    for file in "$@"; do
        local fullpath="$DOTFILES_WORK_TREE/$file"
        local backup="$backup_dir/$file"

        if [ -e "$fullpath" ] || [ -L "$fullpath" ]; then
            mkdir -p "$(dirname "$backup")"
            mv "$fullpath" "$backup"
        fi
    done
}

function command_with_conflict_resolution() {
    local output
    if output=$(_git "$@" 2>&1); then
        return 0
    fi

    echo "$output" >&2

    if echo "$output" | grep -qE "overwritten by (merge|checkout|pull)"; then
        mapfile -t files < <(
            echo "$output" |
            sed -nE 's/^[[:space:]]+([.][^[:space:]]+)/\1/p' |
            sort -u
        )

        resolve_conflicts "${files[@]}"

        _git "$@"
    fi
}

function set_default_config() {
    _git config core.logallrefupdates true
    _git config status.showUntrackedFiles no
   
    _git config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*'
    _git fetch

    local branch=$(_git symbolic-ref --short HEAD || echo main)
    _git branch --set-upstream-to=origin/$branch $branch
}

function get_repo_id() {
    repo_url=$(_git remote get-url origin)

    if [[ "$repo_url" =~ github\.com[:/](.+/[^/.]+)(\.git)?$ ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo "Error: could not extract repo ID from '$repo_url'" >&2
        return 1
    fi
}

function get_ssh_url() {
    echo "git@github.com:$(get_repo_id).git"
}

function get_https_url() {
    echo "git@github.com:$(get_repo_id).git"
}

case "$1" in
    bootstrap)
        shift
        bootstrap "$@"
        ;;
    checkout | merge | pull)
        command_with_conflict_resolution "$@"
        ;;
    switch-to-ssh)
        _git remote set-url origin "$(get_ssh_url)"
        ;;
    *)
        _git "$@"
        ;;
esac
